import { RENDER_CONTEXT } from '../context/render.ts';
import { EnemyPathMover } from './enemy-path-mover.ts';
import { InfectionBullet } from './infection.ts';
import { Tower } from './tower.ts';
import { CurrentWaveContext } from '../context/wave.ts';

const TIME_BEFORE_FIRST_INFECTION_MS = 1000;
const TIME_BETWEEN_INFECTIONS_MS = 5000;
const INFECTION_RANGE_TILES = 3;
const INFECTION_REDUCTION_PER_WAVE = 0.02;
const MIN_TIME_BETWEEN_INFECTIONS_MS = 3000;

export class MalwareEnemy extends EnemyPathMover {
    #timer = TIME_BEFORE_FIRST_INFECTION_MS;
    #infectedTowers: Set<Tower> = new Set();

    tick(): void {
        super.tick();

        if (this.#timer > 0) {
            this.#timer -= RENDER_CONTEXT.deltaTimeMs;
            return;
        }

        for (const tower of Tower.generateTowersInRange(this.tile, INFECTION_RANGE_TILES)) {
            if (!tower.canBeInfected || this.#infectedTowers.has(tower)) {
                continue;
            }

            tower.markForInfection();

            new InfectionBullet({
                position: this.positionPx,
                target: tower,
                speed: 2,
                onHit() {
                    tower.infect();
                }
            });

            this.#infectedTowers.add(tower);
            this.#timer = Math.max(MIN_TIME_BETWEEN_INFECTIONS_MS, TIME_BETWEEN_INFECTIONS_MS * (1 - (INFECTION_REDUCTION_PER_WAVE * CurrentWaveContext.value)));
            break;
        }
    }
}